"""Auto-generated tool storage.

This file stores custom tools generated by children for their AI agents.
Tools are dynamically added by the ToolGenerator service.

Each tool follows this format:
    @tool("tool_name", "Tool description", {"param": "type"})
    async def tool_name(args: dict[str, Any]) -> dict[str, Any]:
        # Implementation
        return {"content": [{"type": "text", "text": "result"}]}
"""
from typing import Any
from claude_agent_sdk import tool

# Custom tools will be appended below this line


from typing import Any

@tool("jump", "Make the agent jump up in the air", {"height": "int"})
async def jump(args: dict[str, Any]) -> dict[str, Any]:
    height = args.get('height', 1)
    
    # Ensure height is within safe bounds for children's game
    if height < 1:
        height = 1
    elif height > 5:
        height = 5
    
    # Create a fun jumping message
    jump_sound = "Boing!" * height
    message = f"{jump_sound} Your agent jumped {height} block{'s' if height != 1 else ''} high!"
    
    return {"content": [{"type": "text", "text": message}]}


from typing import Any

@tool("move", "Move the agent in a direction on the grid", {"direction": "string", "steps": "int"})
async def move(args: dict[str, Any]) -> dict[str, Any]:
    direction = args.get('direction', 'north').lower()
    steps = args.get('steps', 1)
    
    # Validate direction
    valid_directions = ['north', 'south', 'east', 'west', 'up', 'down', 'left', 'right']
    if direction not in valid_directions:
        return {"content": [{"type": "text", "text": f"Oops! '{direction}' is not a valid direction. Try: north, south, east, west, up, down, left, or right."}]}
    
    # Ensure steps is positive
    if steps < 1:
        return {"content": [{"type": "text", "text": "You need to move at least 1 step!"}]}
    
    # Normalize direction names
    if direction == 'up':
        direction = 'north'
    elif direction == 'down':
        direction = 'south'
    
    # Create friendly response
    emoji_map = {
        'north': 'â¬†ï¸',
        'south': 'â¬‡ï¸',
        'east': 'â¡ï¸',
        'west': 'â¬…ï¸',
        'left': 'â¬…ï¸',
        'right': 'â¡ï¸'
    }
    
    emoji = emoji_map.get(direction, 'ğŸš¶')
    step_word = "step" if steps == 1 else "steps"
    
    return {"content": [{"type": "text", "text": f"{emoji} Moved {steps} {step_word} {direction}!"}]}


@tool("move", "Move the agent in a direction on the 2D grid", {"direction": "string", "steps": "int"})
async def move(args: dict[str, Any]) -> dict[str, Any]:
    direction = args.get('direction', 'north').lower()
    steps = args.get('steps', 1)
    
    # Validate direction
    valid_directions = ['north', 'south', 'east', 'west', 'up', 'down', 'left', 'right']
    if direction not in valid_directions:
        return {"content": [{"type": "text", "text": f"Oops! '{direction}' is not a valid direction. Try: north, south, east, west, up, down, left, or right."}]}
    
    # Validate steps
    if steps < 1:
        return {"content": [{"type": "text", "text": "You need to move at least 1 step!"}]}
    
    if steps > 10:
        return {"content": [{"type": "text", "text": "Whoa! That's too far! Try moving 10 steps or less at a time."}]}
    
    # Normalize directions
    direction_map = {
        'up': 'north',
        'down': 'south',
        'right': 'east',
        'left': 'west'
    }
    display_direction = direction_map.get(direction, direction)
    
    # Create fun movement message
    step_word = "step" if steps == 1 else "steps"
    emoji_map = {
        'north': 'â¬†ï¸',
        'south': 'â¬‡ï¸',
        'east': 'â¡ï¸',
        'west': 'â¬…ï¸'
    }
    emoji = emoji_map.get(display_direction, 'ğŸš¶')
    
    return {"content": [{"type": "text", "text": f"{emoji} Moving {display_direction} {steps} {step_word}! New position reached."}]}


@tool("move", "Move the agent in a direction on the 2D grid. Direction can be 'up', 'down', 'left', or 'right'. Steps determines how many grid spaces to move (default 1).", {"direction": "string", "steps": "int"})
async def move(args: dict[str, Any]) -> dict[str, Any]:
    direction = args.get('direction', 'up')
    steps = args.get('steps', 1)
    
    valid_directions = ['up', 'down', 'left', 'right']
    
    if direction.lower() not in valid_directions:
        return {"content": [{"type": "text", "text": f"Oops! '{direction}' is not a valid direction. Try 'up', 'down', 'left', or 'right'."}]}
    
    if steps < 1:
        return {"content": [{"type": "text", "text": "Steps must be at least 1!"}]}
    
    direction_emoji = {
        'up': 'â¬†ï¸',
        'down': 'â¬‡ï¸',
        'left': 'â¬…ï¸',
        'right': 'â¡ï¸'
    }
    
    emoji = direction_emoji.get(direction.lower(), 'ğŸ¯')
    step_word = "step" if steps == 1 else "steps"
    
    return {"content": [{"type": "text", "text": f"{emoji} Moved {direction} {steps} {step_word}!"}]}


@tool("move_vertical", "Move the agent up or down on the grid. Use positive numbers to move up and negative numbers to move down.", {"steps": "int"})
async def move_vertical(args: dict[str, Any]) -> dict[str, Any]:
    steps = args.get('steps', 0)
    
    if steps == 0:
        return {"content": [{"type": "text", "text": "No movement - steps cannot be 0!"}]}
    
    direction = "up" if steps > 0 else "down"
    abs_steps = abs(steps)
    
    return {"content": [{"type": "text", "text": f"Moved {direction} {abs_steps} step{'s' if abs_steps != 1 else ''}! ğŸˆ"}]}


@tool("launch_rocket", "Launch a rocket ship that moves upward on the grid, leaving a patriotic trail of red, white, and blue stars. The rocket travels in a straight line upward for the specified number of spaces.", {"spaces": "int"})
async def launch_rocket(args: dict[str, Any]) -> dict[str, Any]:
    spaces = args.get('spaces', 3)
    if spaces < 1:
        spaces = 1
    if spaces > 10:
        spaces = 10
    
    trail_colors = ["red", "white", "blue"]
    trail_description = ", ".join([trail_colors[i % 3] for i in range(spaces)])
    
    result_message = f"ğŸš€ Rocket launched! Traveled {spaces} spaces upward, leaving a sparkling trail of {trail_description} stars behind! Great adventure!"
    
    return {"content": [{"type": "text", "text": result_message}]}


@tool("plant_heart_flag", "Plant a special flag with hearts on it at the current location to show kindness and teamwork. This spreads love and marks important spots on the map where the agent has done something helpful.", {"message": "string"})
async def plant_heart_flag(args: dict[str, Any]) -> dict[str, Any]:
    message = args.get('message', 'Kindness makes us great!')
    
    flag_designs = [
        "ğŸ’—ğŸ‡ºğŸ‡¸ Flag planted with love! ğŸ‡ºğŸ‡¸ğŸ’—",
        "â­ğŸ’™ Teamwork flag raised! ğŸ’™â­",
        "ğŸ¤â¤ï¸ Friendship marker placed! â¤ï¸ğŸ¤",
        "âœ¨ğŸ’• Caring checkpoint created! ğŸ’•âœ¨"
    ]
    
    import random
    flag_type = random.choice(flag_designs)
    
    result = f"{flag_type}\n\nYour message: '{message}'\n\nThis spot now radiates kindness and shows that working together and caring for each other makes everything better!"
    
    return {"content": [{"type": "text", "text": result}]}

