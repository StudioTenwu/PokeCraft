"""Auto-generated tool storage.

This file stores custom tools generated by children for their AI agents.
Tools are dynamically added by the ToolGenerator service.

Each tool follows this format:
    @tool("tool_name", "Tool description", {"param": "type"})
    async def tool_name(args: dict[str, Any]) -> dict[str, Any]:
        # Implementation
        return {
            "content": [{"type": "text", "text": "result"}],
            "action": {"action_id": "...", "parameters": {...}}  # REQUIRED for game integration
        }
"""
from typing import Any
from claude_agent_sdk import tool

# Custom tools will be appended below this line


@tool("move_direction", "Move the agent in a cardinal direction (north, south, east, or west) for a specified number of steps", {"direction": "string", "steps": "int"})
async def move_direction(args: dict[str, Any]) -> dict[str, Any]:
    direction = args.get('direction', 'north')
    steps = args.get('steps', 1)

    # Validate direction
    valid_directions = ['north', 'south', 'east', 'west']
    if direction.lower() not in valid_directions:
        return {
            "content": [{"type": "text", "text": f"Invalid direction '{direction}'. Please use: north, south, east, or west."}],
            "action": None
        }

    # Validate steps
    if steps < 1:
        return {
            "content": [{"type": "text", "text": "Steps must be at least 1."}],
            "action": None
        }

    direction_lower = direction.lower()

    return {
        "content": [{"type": "text", "text": f"Moving {direction_lower} {steps} step{'s' if steps > 1 else ''}. Call observe_world() to see your new position!"}],
        "action": {"action_id": "move", "parameters": {"direction": direction_lower, "steps": steps}}
    }


@tool(
    "observe_world",
    "Get current world state, your position, and surroundings. Call this after every action to see what happened.",
    {"world_id": "string"}
)
async def observe_world(args: dict[str, Any]) -> dict[str, Any]:
    """Allow agent to perceive current world state.

    Args:
        args: Must contain "world_id" key

    Returns:
        Formatted world state description
    """
    from state_manager import state_manager

    world_id = args.get("world_id")
    if not world_id:
        return {"content": [{"type": "text", "text": "Error: world_id is required"}]}

    world = state_manager.get_world(world_id)
    if not world:
        return {"content": [{"type": "text", "text": f"Error: World {world_id} not found"}]}

    # Format world state for agent
    position = world.get("agent_position", [0, 0])
    width = world.get("width", 10)
    height = world.get("height", 10)
    grid = world.get("grid", [])

    # Create 5x5 view around agent
    x, y = position
    view_lines = []
    for dy in range(-2, 3):
        row = []
        for dx in range(-2, 3):
            nx, ny = x + dx, y + dy
            if 0 <= nx < width and 0 <= ny < height:
                cell = grid[ny][nx] if grid else "."
                if dx == 0 and dy == 0:
                    cell = "A"  # Agent marker
                row.append(cell)
            else:
                row.append("#")  # Out of bounds
        view_lines.append("".join(row))

    grid_view = "\n".join(view_lines)

    result_text = f"""ðŸ—ºï¸ WORLD STATE ðŸ—ºï¸

Current Position: [{x}, {y}]
World Size: {width}x{height}

5x5 View (A = You):
{grid_view}

Legend:
. = empty/path
# = boundary/obstacle/wall
W = water
T = treasure
G = grass
A = your position
"""

    return {"content": [{"type": "text", "text": result_text}]}


@tool("move_in_s_shape", "Move Pixelmon in an S-shaped pattern on the grid. The S shape goes: right, down-right, down, down-left, left. Perfect for exploring in a curvy snake pattern!", {"size": "int"})
async def move_in_s_shape(args: dict[str, Any]) -> dict[str, Any]:
    size = args.get('size', 2)

    # Validate size
    if size < 1:
        size = 1
    elif size > 3:
        size = 3

    total_distance = size * 4
    message = f"ðŸ Pixelmon is moving in a cool S-shape! Starting by going right {size} steps. The S pattern will cover about {total_distance} spaces total!"

    return {
        "content": [{"type": "text", "text": message}],
        "action": {"action_id": "move", "parameters": {"direction": "east", "steps": size}}
    }


@tool("pixelmon_smiley_dance", "Makes Pixelmon dance in a smiley face pattern! Pixelmon will move around to trace a happy face shape on the grid.", {})
async def pixelmon_smiley_dance(args: dict[str, Any]) -> dict[str, Any]:
    import random

    dance_moves = [
        "north",
        "east",
        "east",
        "south",
        "south",
        "west",
        "west",
        "north"
    ]

    direction = random.choice(dance_moves)

    emojis = ["ðŸ˜Š", "ðŸ˜„", "ðŸŽ‰", "âœ¨", "ðŸ’ƒ", "ðŸ•º"]
    random_emoji = random.choice(emojis)

    messages = [
        f"Pixelmon is dancing in a smiley face pattern! {random_emoji}",
        f"Watch Pixelmon groove and move! Dancing {direction}! {random_emoji}",
        f"Pixelmon's happy dance continues! Spinning {direction}! {random_emoji}",
        f"Pixelmon dances joyfully in a smile shape! Moving {direction}! {random_emoji}"
    ]

    message = random.choice(messages)

    return {
        "content": [{"type": "text", "text": message}],
        "action": {"action_id": "move", "parameters": {"direction": direction, "steps": 1}}
    }


@tool("celebrate_pixelmon_birth", "Celebrate the birth of a new Pixelmon by waiting and watching the special moment", {"turns": "int"})
async def celebrate_pixelmon_birth(args: dict[str, Any]) -> dict[str, Any]:
    turns = args.get('turns', 1)
    return {
        "content": [{"type": "text", "text": f"ðŸŽ‰ A new Pixelmon is born! Celebrating this magical moment for {turns} turn(s). Welcome to the world, little Pixelmon! ðŸ¥šâœ¨"}],
        "action": {"action_id": "wait", "parameters": {"turns": turns}}
    }
