<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Playwright E2E Testing Tutorial for AICraft</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f5f5;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px 20px;
            margin-bottom: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .section {
            background: white;
            padding: 30px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        h2 {
            color: #667eea;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #667eea;
        }

        h3 {
            color: #764ba2;
            margin-top: 25px;
            margin-bottom: 15px;
        }

        pre {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            border-left: 4px solid #667eea;
        }

        code {
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em;
        }

        .callout {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .callout.warning {
            background: #fff3e0;
            border-left-color: #ff9800;
        }

        .callout.success {
            background: #e8f5e9;
            border-left-color: #4caf50;
        }

        .workflow-diagram {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin: 30px 0;
            padding: 20px;
            background: #f9f9f9;
            border-radius: 8px;
        }

        .workflow-step {
            text-align: center;
            padding: 15px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            flex: 1;
            margin: 0 10px;
        }

        .workflow-arrow {
            font-size: 2em;
            color: #667eea;
        }

        .api-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        .api-table th,
        .api-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        .api-table th {
            background: #667eea;
            color: white;
            font-weight: 600;
        }

        .api-table tr:hover {
            background: #f5f5f5;
        }

        .code-inline {
            background: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em;
            color: #d63384;
        }

        .toc {
            background: #f9f9f9;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
        }

        .toc ul {
            list-style: none;
            padding-left: 20px;
        }

        .toc li {
            margin: 8px 0;
        }

        .toc a {
            color: #667eea;
            text-decoration: none;
            transition: color 0.2s;
        }

        .toc a:hover {
            color: #764ba2;
            text-decoration: underline;
        }

        .highlight {
            background: #fff9c4;
            padding: 2px 4px;
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üéÆ Playwright E2E Testing Tutorial</h1>
            <div class="subtitle">Building End-to-End Tests for AICraft Pok√©mon Platform</div>
        </header>

        <div class="toc section">
            <h2>üìã Table of Contents</h2>
            <ul>
                <li><a href="#overview">1. Overview: What Are We Testing?</a></li>
                <li><a href="#setup">2. Test Setup & Architecture</a></li>
                <li><a href="#helpers">3. Helper Functions Deep Dive</a></li>
                <li><a href="#workflows">4. Core User Workflows</a></li>
                <li><a href="#playwright-apis">5. Playwright APIs Reference</a></li>
                <li><a href="#debugging">6. Debugging & Tracing</a></li>
                <li><a href="#running">7. Running the Tests</a></li>
            </ul>
        </div>

        <div id="overview" class="section">
            <h2>1. Overview: What Are We Testing?</h2>

            <p>AICraft is a Pok√©mon-themed platform for creating AI agents with custom worlds and tools. We're building <strong>end-to-end (E2E) tests</strong> that simulate real user interactions through the browser.</p>

            <h3>üéØ Core User Workflows</h3>

            <div class="workflow-diagram">
                <div class="workflow-step">
                    <div style="font-size: 2em;">‚ö°</div>
                    <div><strong>1. Create Pok√©mon</strong></div>
                    <div style="font-size: 0.9em; color: #666;">Click default template</div>
                </div>
                <div class="workflow-arrow">‚Üí</div>
                <div class="workflow-step">
                    <div style="font-size: 2em;">üó∫Ô∏è</div>
                    <div><strong>2. Create World</strong></div>
                    <div style="font-size: 0.9em; color: #666;">Generate environment</div>
                </div>
                <div class="workflow-arrow">‚Üí</div>
                <div class="workflow-step">
                    <div style="font-size: 2em;">üîß</div>
                    <div><strong>3. Create Tools</strong></div>
                    <div style="font-size: 0.9em; color: #666;">Define agent actions</div>
                </div>
                <div class="workflow-arrow">‚Üí</div>
                <div class="workflow-step">
                    <div style="font-size: 2em;">üöÄ</div>
                    <div><strong>4. Deploy Agent</strong></div>
                    <div style="font-size: 0.9em; color: #666;">Run in world</div>
                </div>
            </div>

            <div class="callout">
                <strong>üí° Why E2E Tests?</strong>
                <p>Unit tests verify individual functions work correctly. E2E tests verify the <em>entire user experience</em> works correctly‚Äîfrom clicking buttons to seeing results render on screen. They catch integration bugs that unit tests miss.</p>
            </div>
        </div>

        <div id="setup" class="section">
            <h2>2. Test Setup & Architecture</h2>

            <h3>üìÅ File Structure</h3>
            <pre><code>tests/e2e/
‚îú‚îÄ‚îÄ helpers.py                    # Reusable helper functions
‚îú‚îÄ‚îÄ test_pokemon_creation.py      # Test workflow 1
‚îú‚îÄ‚îÄ test_world_creation.py        # Test workflow 2
‚îú‚îÄ‚îÄ test_tool_creation.py         # Test workflow 3
‚îî‚îÄ‚îÄ test_agent_deployment.py      # Test workflow 4</code></pre>

            <h3>üîß Basic Test Template</h3>
            <p>Every test follows this pattern:</p>

<pre><code>from playwright.sync_api import sync_playwright
from helpers import wait_for_app_ready, take_screenshot

def test_something():
    # 1. Launch browser
    with sync_playwright() as p:
        browser = p.chromium.launch(
            channel='chromium',
            headless=False,        # Show browser window
            slow_mo=300            # Slow down actions by 300ms
        )
        page = browser.new_page()

        try:
            # 2. Navigate to app
            page.goto('http://localhost:3000')
            wait_for_app_ready(page)

            # 3. Perform user actions
            button = page.locator('button:has-text("Click Me")')
            button.click()

            # 4. Assert expected results
            result = page.locator('.result')
            assert result.inner_text() == "Success!"

            # 5. Take screenshots for debugging
            take_screenshot(page, "test_success")

        finally:
            # 6. Clean up
            browser.close()</code></pre>

            <div class="callout warning">
                <strong>‚ö†Ô∏è Important:</strong> The app must be running at <code class="code-inline">http://localhost:3000</code> before running tests. Start it with <code class="code-inline">npm run dev</code> in the frontend directory.
            </div>
        </div>

        <div id="helpers" class="section">
            <h2>3. Helper Functions Deep Dive</h2>

            <p>Helper functions abstract common actions so tests stay readable. Let's examine each one:</p>

            <h3>üîç <code>wait_for_app_ready(page)</code></h3>
            <p>Waits for the React app to fully load before interacting with it.</p>

<pre><code>def wait_for_app_ready(page: Page):
    """Wait for the React app to fully load."""
    # Wait for network to be idle (no pending requests)
    page.wait_for_load_state('networkidle')

    # Wait for React to render at least one component
    page.wait_for_selector('.pokemon-container', timeout=10000)

    # Extra buffer for React state updates
    time.sleep(1)</code></pre>

            <div class="callout">
                <strong>üí° Why This Matters:</strong> React apps render asynchronously. If we click a button before React finishes rendering, the button might not exist yet and the test will fail.
            </div>

            <h3>‚ö° <code>create_pokemon(page, pokemon_name)</code></h3>
            <p>Clicks a Pok√©mon button and waits for agent creation to complete.</p>

<pre><code>def create_pokemon(page: Page, pokemon_name: str = "Pikachu") -> dict:
    print(f"  üìù Creating Pok√©mon: {pokemon_name}")

    # Find and click the Pok√©mon button
    # :has-text() selector finds buttons containing the text
    pokemon_button = page.locator(f'button:has-text("{pokemon_name}")')

    # expect() waits up to 5 seconds for button to be visible
    expect(pokemon_button).to_be_visible(timeout=5000)
    pokemon_button.click()

    # Wait for creation to complete
    # Avatar generation can take 30-60 seconds
    page.wait_for_selector('button:has-text("Create World")', timeout=60000)

    # Extract agent ID from dropdown
    select = page.locator('select').first
    agent_id = select.input_value()

    return {'id': agent_id, 'name': pokemon_name}</code></pre>

            <h3>üó∫Ô∏è <code>create_world(page, description)</code></h3>
            <p>Creates a world by filling in a description and submitting the form.</p>

<pre><code>def create_world(page: Page, description: str) -> dict:
    print(f"  üìù Creating world: {description[:50]}...")

    # Fill in the textarea
    textarea = page.locator('textarea').first
    expect(textarea).to_be_visible(timeout=5000)
    textarea.fill(description)

    # Click submit button
    # Button is disabled until textarea is filled
    submit_btn = page.locator('button:has-text("Create World")').first
    expect(submit_btn).to_be_enabled(timeout=5000)
    submit_btn.click()

    # Wait for world to render (canvas appears)
    page.wait_for_selector('canvas', timeout=60000)

    # Extract world name from page
    world_name_el = page.locator('h3:has-text("üó∫Ô∏è")').first
    world_name = world_name_el.inner_text().replace('üó∫Ô∏è ', '')

    return {'name': world_name}</code></pre>

            <h3>üîß <code>create_tool(page, tool_description)</code></h3>
            <p>Creates a tool for the agent.</p>

<pre><code>def create_tool(page: Page, tool_description: str) -> dict:
    # Find the textarea for tool description
    # We use .nth(1) because it's the SECOND textarea on the page
    # (first is for world description)
    textarea = page.locator('textarea[placeholder*="tool"]').or_(
        page.locator('textarea').nth(1)
    )
    textarea.fill(tool_description)

    # Submit
    generate_btn = page.locator('button:has-text("Generate Tool")')
    generate_btn.click()

    # Wait for tool card to appear
    page.wait_for_selector('.pokemon-container:has-text("Tool:")', timeout=60000)

    # Extract tool name from the card
    tool_card = page.locator('.pokemon-container:has-text("Tool:")').first
    tool_text = tool_card.inner_text()
    tool_name = tool_text.split('\n')[0].replace('Tool: ', '')

    return {'name': tool_name}</code></pre>

            <h3>üì∏ <code>take_screenshot(page, name)</code></h3>
            <p>Captures a full-page screenshot for debugging.</p>

<pre><code>def take_screenshot(page: Page, name: str):
    filename = f"/tmp/e2e_{name}_{int(time.time())}.png"
    page.screenshot(path=filename, full_page=True)
    print(f"  üì∏ Screenshot saved: {filename}")
    return filename</code></pre>

            <h3>üìã <code>capture_console_logs(page)</code></h3>
            <p>Captures browser console logs for debugging React errors.</p>

<pre><code>def capture_console_logs(page: Page) -> list[str]:
    logs = []

    # Set up event listener for console messages
    def handle_console(msg):
        logs.append(f"[{msg.type}] {msg.text}")

    page.on("console", handle_console)
    return logs

# Later in the test:
logs = capture_console_logs(page)
# ... run test ...
print_console_logs(logs)  # Print last 20 logs</code></pre>
        </div>

        <div id="workflows" class="section">
            <h2>4. Core User Workflows</h2>

            <h3>Workflow 1: Pok√©mon Creation</h3>
            <p><strong>Goal:</strong> User clicks "Pikachu" ‚Üí Agent is created ‚Üí "Create World" button appears</p>

<pre><code>def test_pokemon_creation():
    with sync_playwright() as p:
        browser = p.chromium.launch(channel='chromium', headless=False, slow_mo=300)
        page = browser.new_page()
        logs = capture_console_logs(page)

        try:
            # Step 1: Load app
            page.goto('http://localhost:3000')
            wait_for_app_ready(page)
            take_screenshot(page, "01_app_loaded")

            # Step 2: Create Pikachu
            agent = create_pokemon(page, "Pikachu")
            assert agent['name'] == "Pikachu"
            take_screenshot(page, "02_pikachu_created")

            # Step 3: Verify "Create World" button appears
            create_world_btn = page.locator('button:has-text("Create World")')
            assert create_world_btn.count() > 0

            print("‚úÖ TEST PASSED")

        except AssertionError as e:
            print(f"‚ùå TEST FAILED: {e}")
            take_screenshot(page, "FAILED_pokemon_creation")
            print_console_logs(logs)

        finally:
            browser.close()</code></pre>

            <h3>Workflow 2: World Creation</h3>
            <p><strong>Goal:</strong> Create agent ‚Üí Create world ‚Üí World canvas renders</p>

<pre><code>def test_world_creation():
    with sync_playwright() as p:
        browser = p.chromium.launch(channel='chromium', headless=False, slow_mo=300)
        page = browser.new_page()

        try:
            # Step 1: Load app
            page.goto('http://localhost:3000')
            wait_for_app_ready(page)

            # Step 2: Create Pikachu
            agent = create_pokemon(page, "Pikachu")
            take_screenshot(page, "01_pikachu_created")

            # Step 3: Create world
            world = create_world(page, "a mystical forest with glowing trees")
            assert 'name' in world
            take_screenshot(page, "02_world_created")

            # Step 4: Verify canvas rendered
            canvas = page.locator('canvas')
            assert canvas.count() > 0, "Canvas should be visible"

            # Step 5: Verify action display
            action_display = page.locator('.pokemon-container:has-text("Movement")')
            assert action_display.count() > 0, "Actions should be categorized"

            print("‚úÖ TEST PASSED")

        finally:
            browser.close()</code></pre>

            <h3>Workflow 3: Full Pipeline (Pok√©mon ‚Üí World ‚Üí Tool ‚Üí Deploy)</h3>

<pre><code>def test_full_pipeline():
    with sync_playwright() as p:
        browser = p.chromium.launch(channel='chromium', headless=False, slow_mo=300)
        page = browser.new_page()

        try:
            # 1. Load app
            page.goto('http://localhost:3000')
            wait_for_app_ready(page)

            # 2. Create Pikachu
            agent = create_pokemon(page, "Pikachu")
            take_screenshot(page, "01_pokemon")

            # 3. Create world
            world = create_world(page, "a grassy meadow")
            take_screenshot(page, "02_world")

            # 4. Create tool
            tool = create_tool(page, "move forward one step")
            take_screenshot(page, "03_tool")

            # 5. Deploy agent
            success = deploy_agent(page)
            assert success, "Deployment UI should load"
            take_screenshot(page, "04_deployed")

            print("‚úÖ FULL PIPELINE TEST PASSED")

        finally:
            browser.close()</code></pre>
        </div>

        <div id="playwright-apis" class="section">
            <h2>5. Playwright APIs Reference</h2>

            <h3>üîç Locating Elements</h3>

            <table class="api-table">
                <thead>
                    <tr>
                        <th>Method</th>
                        <th>Usage</th>
                        <th>Example</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>page.locator(selector)</code></td>
                        <td>Find element by CSS selector</td>
                        <td><code>page.locator('button')</code></td>
                    </tr>
                    <tr>
                        <td><code>:has-text()</code></td>
                        <td>Find by text content</td>
                        <td><code>page.locator('button:has-text("Click")')</code></td>
                    </tr>
                    <tr>
                        <td><code>text=/regex/</code></td>
                        <td>Find by regex pattern</td>
                        <td><code>page.locator('text=/Create.*/')</code></td>
                    </tr>
                    <tr>
                        <td><code>.first</code></td>
                        <td>Get first matching element</td>
                        <td><code>page.locator('button').first</code></td>
                    </tr>
                    <tr>
                        <td><code>.nth(n)</code></td>
                        <td>Get nth element (0-indexed)</td>
                        <td><code>page.locator('button').nth(2)</code></td>
                    </tr>
                </tbody>
            </table>

            <h3>üé¨ Interactions</h3>

            <table class="api-table">
                <thead>
                    <tr>
                        <th>Method</th>
                        <th>Usage</th>
                        <th>Example</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>.click()</code></td>
                        <td>Click element</td>
                        <td><code>button.click()</code></td>
                    </tr>
                    <tr>
                        <td><code>.fill(text)</code></td>
                        <td>Type text into input</td>
                        <td><code>textarea.fill("Hello world")</code></td>
                    </tr>
                    <tr>
                        <td><code>.select_option(value)</code></td>
                        <td>Select dropdown option</td>
                        <td><code>select.select_option(value="123")</code></td>
                    </tr>
                    <tr>
                        <td><code>.inner_text()</code></td>
                        <td>Get text content</td>
                        <td><code>text = div.inner_text()</code></td>
                    </tr>
                    <tr>
                        <td><code>.count()</code></td>
                        <td>Count matching elements</td>
                        <td><code>num = page.locator('button').count()</code></td>
                    </tr>
                </tbody>
            </table>

            <h3>‚è≥ Waiting & Assertions</h3>

            <table class="api-table">
                <thead>
                    <tr>
                        <th>Method</th>
                        <th>Usage</th>
                        <th>Example</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>page.wait_for_selector()</code></td>
                        <td>Wait for element to appear</td>
                        <td><code>page.wait_for_selector('canvas', timeout=10000)</code></td>
                    </tr>
                    <tr>
                        <td><code>page.wait_for_load_state()</code></td>
                        <td>Wait for page to load</td>
                        <td><code>page.wait_for_load_state('networkidle')</code></td>
                    </tr>
                    <tr>
                        <td><code>expect().to_be_visible()</code></td>
                        <td>Assert element is visible</td>
                        <td><code>expect(button).to_be_visible(timeout=5000)</code></td>
                    </tr>
                    <tr>
                        <td><code>expect().to_be_enabled()</code></td>
                        <td>Assert element is enabled</td>
                        <td><code>expect(button).to_be_enabled()</code></td>
                    </tr>
                </tbody>
            </table>

            <div class="callout">
                <strong>üí° Timeout Best Practices:</strong>
                <ul>
                    <li>Short waits (5s): For UI elements that render quickly</li>
                    <li>Medium waits (10-30s): For API calls</li>
                    <li>Long waits (60s): For AI generation (LLM, image generation)</li>
                </ul>
            </div>

            <h3>üéØ Combining Selectors</h3>

<pre><code># Find button with specific text
page.locator('button:has-text("Deploy")')

# Find button with specific class AND text
page.locator('button.pokemon-button:has-text("Pikachu")')

# Find input inside a specific container
page.locator('.pokemon-container textarea')

# Alternative: use .or_() for fallback selectors
textarea = page.locator('textarea[placeholder*="tool"]').or_(
    page.locator('textarea').nth(1)
)</code></pre>
        </div>

        <div id="debugging" class="section">
            <h2>6. Debugging & Tracing</h2>

            <h3>üì∏ Screenshots</h3>
            <p>Take screenshots at key steps to visually debug what the browser sees:</p>

<pre><code>take_screenshot(page, "01_before_click")
button.click()
take_screenshot(page, "02_after_click")</code></pre>

            <p>Screenshots are saved to <code class="code-inline">/tmp/e2e_*.png</code></p>

            <h3>üìã Console Logs</h3>
            <p>Capture React error messages and debug logs:</p>

<pre><code>logs = capture_console_logs(page)
# ... run test ...
if test_failed:
    print_console_logs(logs)  # Print last 20 logs</code></pre>

            <h3>üé• Playwright Trace Viewer</h3>
            <p>The most powerful debugging tool‚Äîrecords <em>everything</em> during the test:</p>

<pre><code>context = browser.new_context()
context.tracing.start(screenshots=True, snapshots=True, sources=True)

# ... run test ...

# Save trace file
context.tracing.stop(path="/tmp/trace.zip")</code></pre>

            <p>View the trace:</p>
<pre><code>playwright show-trace /tmp/trace.zip</code></pre>

            <div class="callout success">
                <strong>‚úÖ Trace Viewer Shows:</strong>
                <ul>
                    <li>Every action taken (clicks, types, waits)</li>
                    <li>Screenshots before/after each action</li>
                    <li>DOM snapshots at each step</li>
                    <li>Network requests and responses</li>
                    <li>Console logs</li>
                    <li>Execution timeline</li>
                </ul>
            </div>

            <h3>üê¢ Slow Motion Mode</h3>
            <p>Slow down test execution to see what's happening:</p>

<pre><code>browser = p.chromium.launch(
    headless=False,    # Show browser window
    slow_mo=300        # 300ms delay between actions
)</code></pre>

            <h3>üîç Debugging Checklist</h3>
            <ol>
                <li><strong>Is the app running?</strong> Check <code class="code-inline">http://localhost:3000</code></li>
                <li><strong>Did the element load?</strong> Check screenshot</li>
                <li><strong>Is the selector correct?</strong> Use browser DevTools to verify</li>
                <li><strong>Did React render?</strong> Check console logs for errors</li>
                <li><strong>Was the timeout too short?</strong> Increase timeout and retry</li>
                <li><strong>Did the API call fail?</strong> Check network tab in trace viewer</li>
            </ol>
        </div>

        <div id="running" class="section">
            <h2>7. Running the Tests</h2>

            <h3>üì¶ Installation</h3>

<pre><code># Install Playwright
pip install playwright

# Install browser binaries
playwright install chromium</code></pre>

            <h3>‚ñ∂Ô∏è Running Individual Tests</h3>

<pre><code># Run in headed mode (see browser)
HEADED=1 python tests/e2e/test_pokemon_creation.py

# Run in headless mode (faster, no UI)
python tests/e2e/test_pokemon_creation.py</code></pre>

            <h3>üèÉ Running All Tests</h3>

<pre><code># Run all E2E tests sequentially
python tests/e2e/run_all_tests.py</code></pre>

            <h3>‚öôÔ∏è Environment Variables</h3>

            <table class="api-table">
                <thead>
                    <tr>
                        <th>Variable</th>
                        <th>Purpose</th>
                        <th>Default</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>HEADED</code></td>
                        <td>Show browser window (1) or run headless (0)</td>
                        <td>0 (headless)</td>
                    </tr>
                    <tr>
                        <td><code>APP_URL</code></td>
                        <td>Frontend URL</td>
                        <td>http://localhost:3000</td>
                    </tr>
                </tbody>
            </table>

            <h3>üéØ Test Execution Flow</h3>

<pre><code>1. Start backend server (Terminal 1)
   ‚Üí cd backend && uv run uvicorn src.main:app --reload

2. Start frontend dev server (Terminal 2)
   ‚Üí cd frontend && npm run dev

3. Run E2E tests (Terminal 3)
   ‚Üí cd tests/e2e && HEADED=1 python test_pokemon_creation.py

4. View results
   ‚Üí Check terminal output for PASS/FAIL
   ‚Üí View screenshots in /tmp/
   ‚Üí View trace: playwright show-trace /tmp/trace_*.zip</code></pre>

            <div class="callout warning">
                <strong>‚ö†Ô∏è Pre-Test Checklist:</strong>
                <ul>
                    <li>‚úÖ Backend running at <code class="code-inline">http://localhost:8000</code></li>
                    <li>‚úÖ Frontend running at <code class="code-inline">http://localhost:3000</code></li>
                    <li>‚úÖ Database initialized (<code class="code-inline">agents.db</code> exists)</li>
                    <li>‚úÖ Avatar model downloaded (<code class="code-inline">~/.AICraft/models/schnell-3bit/</code>)</li>
                </ul>
            </div>

            <h3>üìä Expected Output</h3>

<pre><code>================================================================================
TEST: Pok√©mon Creation Workflow
================================================================================
  üñ•Ô∏è  Mode: Headed

[1/3] Loading app...
  üì∏ Screenshot saved: /tmp/e2e_01_app_loaded_1699999999.png

[2/3] Creating Pikachu...
  üìù Creating Pok√©mon: Pikachu
  ‚è≥ Waiting for agent creation...
  ‚úÖ Pok√©mon created: Pikachu (ID: 12a4b2d6...)
  üì∏ Screenshot saved: /tmp/e2e_02_pikachu_created_1699999999.png

[3/3] Verifying agent is ready...

================================================================================
‚úÖ TEST PASSED: Pok√©mon Creation
================================================================================
  üìä Trace saved: /tmp/trace_pokemon_creation_SUCCESS.zip
     View with: playwright show-trace /tmp/trace_pokemon_creation_SUCCESS.zip

Closing browser...</code></pre>
        </div>

        <div class="section">
            <h2>üéì Summary</h2>

            <p>You've learned how to:</p>
            <ul style="padding-left: 40px; margin: 20px 0;">
                <li>‚úÖ Structure E2E tests with helper functions for reusability</li>
                <li>‚úÖ Use Playwright APIs to locate elements, interact with the page, and wait for results</li>
                <li>‚úÖ Test all four core workflows: Pok√©mon creation, world creation, tool creation, and deployment</li>
                <li>‚úÖ Debug tests using screenshots, console logs, and trace viewer</li>
                <li>‚úÖ Run tests in headed/headless mode</li>
            </ul>

            <div class="callout success">
                <strong>üöÄ Next Steps:</strong>
                <ul>
                    <li>Run each test individually to verify they work</li>
                    <li>Add more edge case tests (error handling, validation, etc.)</li>
                    <li>Integrate tests into CI/CD pipeline</li>
                    <li>Add visual regression testing (screenshot comparison)</li>
                </ul>
            </div>

            <h3>üìö Resources</h3>
            <ul style="padding-left: 40px;">
                <li><a href="https://playwright.dev/python/docs/intro" target="_blank">Playwright Python Docs</a></li>
                <li><a href="https://playwright.dev/python/docs/selectors" target="_blank">Selector Strategies</a></li>
                <li><a href="https://playwright.dev/python/docs/debug" target="_blank">Debugging Guide</a></li>
                <li><a href="https://playwright.dev/python/docs/api/class-page" target="_blank">Page API Reference</a></li>
            </ul>
        </div>

        <footer style="text-align: center; padding: 40px 20px; color: #666;">
            <p>Created for AICraft Pok√©mon Platform</p>
            <p style="font-size: 0.9em; margin-top: 10px;">Tutorial generated by Claude Code</p>
        </footer>
    </div>
</body>
</html>
